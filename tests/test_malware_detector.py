"""Tests for the malware detection model."""

import pytest
import torch
from pathlib import Path

from src.models.malware_detector import (
    MultiHeadMalwareDetector, 
    MalwareDetector, 
    MalwareDataset, 
    train_multi_head_model,
    train_model
)


class TestMultiHeadMalwareDetector:
    """Test cases for MultiHeadMalwareDetector class."""
    
    def test_model_initialization(self):
        """Test model initialization with different parameters."""
        # Test default initialization
        model = MultiHeadMalwareDetector()
        assert model.pe_features_size == 50
        assert model.byte_histogram_size == 256
        assert model.opcode_features_size == 300
        assert model.api_features_size == 200
        assert model.dropout_rate == 0.3
        assert model.fusion_dropout_rate == 0.4
        
        # Test custom initialization
        model = MultiHeadMalwareDetector(
            pe_features_size=30,
            byte_histogram_size=128,
            opcode_features_size=150,
            api_features_size=100,
            dropout_rate=0.5,
            fusion_dropout_rate=0.6
        )
        assert model.pe_features_size == 30
        assert model.byte_histogram_size == 128
        assert model.opcode_features_size == 150
        assert model.api_features_size == 100
        assert model.dropout_rate == 0.5
        assert model.fusion_dropout_rate == 0.6
    
    def test_forward_pass(self):
        """Test forward pass through the multi-headed model."""
        model = MultiHeadMalwareDetector(
            pe_features_size=30,
            byte_histogram_size=128,
            opcode_features_size=150,
            api_features_size=100
        )
        
        # Test with batch of samples
        batch_size = 4
        total_features = 30 + 128 + 150 + 100  # 408
        x = torch.randn(batch_size, total_features)
        output = model(x)
        
        assert output.shape == (batch_size, 2)  # 2 classes for binary classification
    
    def test_predict(self):
        """Test prediction method."""
        model = MultiHeadMalwareDetector(
            pe_features_size=30,
            byte_histogram_size=128,
            opcode_features_size=150,
            api_features_size=100
        )
        
        x = torch.randn(3, 30 + 128 + 150 + 100)
        predictions = model.predict(x)
        
        assert predictions.shape == (3,)
        assert torch.all((predictions == 0) | (predictions == 1))  # Binary output
    
    def test_feature_importance(self):
        """Test feature importance extraction."""
        model = MultiHeadMalwareDetector(
            pe_features_size=30,
            byte_histogram_size=128,
            opcode_features_size=150,
            api_features_size=100
        )
        
        x = torch.randn(2, 30 + 128 + 150 + 100)
        feature_importance = model.get_feature_importance(x)
        
        assert 'pe_latent' in feature_importance
        assert 'byte_latent' in feature_importance
        assert 'opcode_latent' in feature_importance
        assert 'api_latent' in feature_importance
        
        assert feature_importance['pe_latent'].shape == (2, 32)
        assert feature_importance['byte_latent'].shape == (2, 128)
        assert feature_importance['opcode_latent'].shape == (2, 128)
        assert feature_importance['api_latent'].shape == (2, 64)
    
    def test_model_save_load(self, tmp_path):
        """Test model saving and loading."""
        model = MultiHeadMalwareDetector(
            pe_features_size=30,
            byte_histogram_size=128,
            opcode_features_size=150,
            api_features_size=100
        )
        
        # Save model
        save_path = tmp_path / "test_multihead_model.pt"
        model.save_model(save_path)
        assert save_path.exists()
        
        # Load model
        loaded_model = MultiHeadMalwareDetector.load_model(save_path)
        
        # Check if parameters match
        assert loaded_model.pe_features_size == model.pe_features_size
        assert loaded_model.byte_histogram_size == model.byte_histogram_size
        assert loaded_model.opcode_features_size == model.opcode_features_size
        assert loaded_model.api_features_size == model.api_features_size
        assert loaded_model.dropout_rate == model.dropout_rate
        assert loaded_model.fusion_dropout_rate == model.fusion_dropout_rate
        
        # Test if loaded model produces same output
        x = torch.randn(2, 30 + 128 + 150 + 100)
        original_output = model(x)
        loaded_output = loaded_model(x)
        
        torch.testing.assert_close(original_output, loaded_output)


class TestLegacyMalwareDetector:
    """Test cases for legacy MalwareDetector class (backward compatibility)."""
    
    def test_model_initialization(self):
        """Test legacy model initialization with different parameters."""
        # Test default initialization
        model = MalwareDetector()
        assert model.input_size == 1024
        assert model.hidden_sizes == [512, 256, 128]
        assert model.dropout_rate == 0.3
        
        # Test custom initialization
        model = MalwareDetector(input_size=512, hidden_sizes=[256, 128], dropout_rate=0.5)
        assert model.input_size == 512
        assert model.hidden_sizes == [256, 128]
        assert model.dropout_rate == 0.5
    
    def test_forward_pass(self):
        """Test forward pass through the legacy network."""
        model = MalwareDetector(input_size=100, hidden_sizes=[50, 25])
        
        # Test with batch of samples
        batch_size = 4
        x = torch.randn(batch_size, 100)
        output = model(x)
        
        assert output.shape == (batch_size, 1)
        assert torch.all((output >= 0) & (output <= 1))  # Sigmoid output
    
    def test_predict(self):
        """Test legacy prediction method."""
        model = MalwareDetector(input_size=100, hidden_sizes=[50])
        
        x = torch.randn(3, 100)
        predictions = model.predict(x, threshold=0.5)
        
        assert predictions.shape == (3, 1)
        assert torch.all((predictions == 0) | (predictions == 1))  # Binary output
    
    def test_model_save_load(self, tmp_path):
        """Test legacy model saving and loading."""
        model = MalwareDetector(input_size=100, hidden_sizes=[50])
        
        # Save model
        save_path = tmp_path / "test_legacy_model.pt"
        model.save_model(save_path)
        assert save_path.exists()
        
        # Load model
        loaded_model = MalwareDetector.load_model(save_path)
        
        # Check if parameters match
        assert loaded_model.input_size == model.input_size
        assert loaded_model.hidden_sizes == model.hidden_sizes
        assert loaded_model.dropout_rate == model.dropout_rate
        
        # Test if loaded model produces same output
        x = torch.randn(2, 100)
        original_output = model(x)
        loaded_output = loaded_model(x)
        
        torch.testing.assert_close(original_output, loaded_output)


class TestMalwareDataset:
    """Test cases for MalwareDataset class."""
    
    def test_dataset_creation(self):
        """Test dataset creation and access."""
        features = torch.randn(10, 100)
        labels = torch.randint(0, 2, (10,))
        
        dataset = MalwareDataset(features.numpy(), labels.numpy())
        
        assert len(dataset) == 10
        assert dataset.features.shape == (10, 100)
        assert dataset.labels.shape == (10,)
        
        # Test item access
        sample_features, sample_label = dataset[0]
        assert sample_features.shape == (100,)
        assert sample_label.shape == ()


class TestTraining:
    """Test cases for training functionality."""
    
    def test_multi_head_training_loop(self):
        """Test multi-headed training loop with small dataset."""
        # Create small multi-headed model and dataset
        model = MultiHeadMalwareDetector(
            pe_features_size=20,
            byte_histogram_size=64,
            opcode_features_size=50,
            api_features_size=30
        )
        
        # Create dummy data
        total_features = 20 + 64 + 50 + 30  # 164
        features = torch.randn(20, total_features)
        labels = torch.randint(0, 2, (20,))
        
        dataset = MalwareDataset(features.numpy(), labels.numpy())
        train_loader = torch.utils.data.DataLoader(dataset, batch_size=4)
        val_loader = torch.utils.data.DataLoader(dataset, batch_size=4)
        
        # Train for a few epochs
        history = train_multi_head_model(
            model=model,
            train_loader=train_loader,
            val_loader=val_loader,
            epochs=3,
            learning_rate=0.001
        )
        
        assert 'train_losses' in history
        assert 'val_losses' in history
        assert len(history['train_losses']) == 3
        assert len(history['val_losses']) == 3
        
        # Check that losses are decreasing (generally)
        assert history['train_losses'][-1] <= history['train_losses'][0] * 1.5
    
    def test_legacy_training_loop(self):
        """Test legacy training loop with small dataset."""
        # Create small legacy model and dataset
        model = MalwareDetector(input_size=50, hidden_sizes=[25])
        
        # Create dummy data
        features = torch.randn(20, 50)
        labels = torch.randint(0, 2, (20,))
        
        dataset = MalwareDataset(features.numpy(), labels.numpy())
        train_loader = torch.utils.data.DataLoader(dataset, batch_size=4)
        val_loader = torch.utils.data.DataLoader(dataset, batch_size=4)
        
        # Train for a few epochs
        history = train_model(
            model=model,
            train_loader=train_loader,
            val_loader=val_loader,
            epochs=3,
            learning_rate=0.001
        )
        
        assert 'train_losses' in history
        assert 'val_losses' in history
        assert len(history['train_losses']) == 3
        assert len(history['val_losses']) == 3
        
        # Check that losses are decreasing (generally)
        assert history['train_losses'][-1] <= history['train_losses'][0] * 1.5


if __name__ == "__main__":
    pytest.main([__file__])
